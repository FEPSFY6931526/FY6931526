<!DOCTYPE html>

<html>
  <head>
  <img src ="WebBanner2023.png" alt="Banner" width="900" height="300" style="text-align: center;">
    <h1 style="font-family: calibri;"><b>ENG0018 Computer Laboratory 2025/26</b></h1>
    <h2 style="font-family: calibri;">Student URN: 6931526</h2>
  <hr>
  <h2 style="font-family:calibri;"><b>Conference Paper: An Analysis of Computer Clusters and their use cases.</b></h2>
  <!-- <hr> -->



    <style>
      p.ex1 {
        margin-left: 250px;
      }
    </style>
    <style>
      html {
        scroll-behavior: smooth;
      }
    </style>
  </head>
<meta name="viewport" content="width=device-width, intial-scale=1">
<!-- <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css"> -->
 <link rel="stylesheet" href="style.css">
<style>
  .mySlides {display:none}
</style>
<!-- <body style="background-color:#FFFFFF;margin-left:50px;"> -->
  <body>
<div class="header">
  <!-- <h2>...</h2> -->
  <div class="progress-container">
    <div class="progress-bar" id="myBar"></div>
  </div>
</div>
<script>
  window.onscroll = function() {myFunction()};

function myFunction() {
  var winScroll = document.body.scrollTop || document.documentElement.scrollTop;
  var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
  var scrolled = (winScroll / height) * 100;
  document.getElementById("myBar").style.width = scrolled + "%";
} 
</script>
  <hr>

<p class="ex1">
<!table of contents>
  <table style="margin-left: auto;margin-right: auto; border-radius: 25%;">
    <tr>
      <th><h3>Table of contents</h3></th>
    </tr>
    <tr>
      <td><a href="#Abstract">Abstract</td>
    </tr>
    <tr>
      <td><a href="#Introduction">I: Introduction</td>
    </tr>
    <tr>
      <td><a href="#What">II: What is cluster computing?</td>
    </tr>
    <tr>
        <td><a href="#How">III: How is cluster computing achieved?</a></td>
    </tr>
    <tr>
      <td><a href="#Why">IV: What is the reason for using a computer cluster?</a></td>
    </tr>
    <tr>
      <td><a href="#Examples">V: Examples of the use of computer clusters effectively</a></td>
    </tr>

    <tr>
      <td><a href="#References">References</td>
    </tr>
  </table>
</p>
  
  <!-- <hr> -->
  <div class="abs" style="overflow: visible;">
  <h3 id="Abstract" style="text-align: center; padding-top: 1rem;">Abstract</h3>
  <!-- <p class="ex1"> -->
    <p>
      This article explains what cluster computing is and why it came around, how it is achieved, through both physical components and software and applications. As well as the reasons behind its use, as well as examples of its use, including the Millenium Simulation.

      This article goes on to explain what a computer cluster is, how they are designed, their use case and then goes 
  </p>
  </div>
  <!-- <hr> -->
<div class="IntroDiv" style="overflow: visible;">
  <h3 id="Introduction">I: Introduction</h3>
  <p id="Introduction_InText">
    There are many situations in which being able to run software in a parallel state is useful, one such area is complex simulations, that often require hundreds of hours of central processing unit (CPU) time.
    This led to the development and adaptation of computer clusters, or multiple computers all working on the same simulation or program, running simultaneously to produce the desired outcome. But why clusters of computers, why not just use one very powerful computer.
    The answer, as it is with so many questions we face today, is money. But this article will tell you a bit more about what and why, alongside a couple of examples from the real world.
  </p>
</div>



<div class="WhatDiv" style="overflow: visible;">
  <h3 id="What">II: What is cluster computing?</h3>
  <p id="What_InText">
    When computers where first used to simulate real world problems and solutions, they worked in a sequential manner, that is, each instruction was processed one after another.
    With early computers, this was deemed to be perfectly acceptable. “In the 1980s, it was believed that computer performance was best improved by creating faster and more efficient processors.” <a href="#ref1">(Baker, Buyya, 1999)</a>.
    Yet as the amount of data generated by people increased, so did the need to compute this data effectively and efficiently. The answer was to switch towards parallel processing. Instead of performing one instruction at a time, processors were developed with multiple cores. At any given time, each core could perform a different instruction, and data could be manipulated faster.
    Despite this, the need for faster computers was still prevalent. According to Mark Baker and Rajkumar Buyya, the process boiled down to “…linking together two or more computers jointly to solve some problem.” <a href="#ref1">(Baker, Buyya, 1999)</a>. The difference between using a powerful multi-core processor in one computer versus 4-5 less powerful computers is one of cost.
    As powerful computers became more expensive, the need for a cheaper alternative was necessary. Why spend an excessive amount of funds on one singular computer, which may only be used once or twice, when you could instead use far more less expensive options, and then run them parallel to each other. Whilst it isn’t as simple as my above description, the need was there, and it needed to be met. If one computer could perform multiple instructions at once, why couldn’t multiple computers run at once performing the same task.
  </p>
</div>


<div class="IntroDiv">
  <h3 id="How">III: How is cluster computing achieved?</h3>
  <p id="How_InText">
  There are two sides to cluster computing, firstly there is the physical. Computers in a cluster can either be ‘dedicated’, or ‘non-dedicated’ <a href="#ref3">(Buyya, 1999)</a> according to Rajkumar Buyya in his book <a href="#ref3">“High Performance Cluster Computing: Systems and Architectures, Volume 1”</a>. Buyya determines the difference between the two as being “based on the ownership of the workstations” <a href="#ref3">(Buyya, 1999)</a>. A ‘dedicated’ cluster has all resources always shared between each workstation, whereas a ‘non-dedicated' cluster shares any idle resources from a non-active workstation to the cluster. 
  The second side of cluster computing is the software. Software and programs can be written with the specific intent of being run on a cluster, however this exposes just how niche clusters can be at times. If each cluster is built differently, and the code required to run a program is written for an individual cluster, it may not be possible to run that code on a different cluster or computer. This does increase the cost, as now you need either specialised code designed for your system, or someone else’s code needs to be adapted for your system. Both options can become more expensive if it takes time to develop the result you need.  

  </p>
</div>



  <div class="WhatDiv">
<h3 id="Why">IV: What is the reason for using a computer cluster?</h3>
  <p id="Why_InText">
    With the correct setup and execution, a computer cluster could efficiently run a complex simulation, that might ordinarily take a normal computer much longer. We can use Big O Time notation to give a better picture about what I mean. Let’s say a normal computer can perform the simulation in <i>O(5n+3)</i> time. This means that the more data, <i>n</i>, that is used, the longer it will take to run. For every <i>n</i> data it takes <i>5n + 3</i> seconds to run. If the simulation was using 5 pieces of data it would take 25 + 3, or 28 seconds. If our cluster ran the same simulation, but with adapted software that takes advantage of the nature of the cluster, we might find that the Big O time complexity was <i>O(n+5)</i>, which if given the same pieces of data, would take 5 + 5, or 10 seconds. With so little data, this seems like a minimal gain, but if scaled up correctly, we could use 4500 pieces of data, and the cluster would perform much faster than the normal computer. The figure below shows this information in an easier setting. This example begins to show just how limiting a single computer can be. If you start to look at larger and more complex problems, the need for parallel computations becomes more prevalent. 
  </p>
</div>

<div style="padding: 10px;"></div>


  <!-- <h3 id="Figure1">Figure 1: Comparison of Big O Time complexities</h3> -->
  <div class="Table" style="text-align: center; padding-top: 1rem;">  
  <table style="justify-content: center;">
    <tr>
      <th>Number of Data, n</th>
      <th>Big O Time (5n+3)</th>
      <th>Big O Time (n+5)</th>
      <th>Time comparison (s)</th>
    </tr>
    <tr>
      <td>5</td>
      <td>5(5)+3</td>
      <td>(5)+5</td>
      <td>28 vs 8</td>
    </tr>
    <tr>
      <td>10</td>
      <td>5(10)+3</td>
      <td>(10)+5</td>
      <td>53 vs 15</td>
    </tr>
    <tr>
      <td>100</td>
      <td>5(100)+3</td>
      <td>(100)+5</td>
      <td>503 vs 105</td>
    </tr>
    <tr>
      <td>10000</td>
      <td>5(10000)+3</td>
      <td>(10000)+5</td>
      <td>50003 vs 10005</td>
    </tr>
    <caption style="text-align: center; padding-bottom: 5px;"><b>Figure 1:</b> Comparison of Big O Time complexities</caption>
  </table>
</div>


<div class="IntroDiv">
<h3 id="Examples">V: Examples of the use of computer clusters effectively</h3>
  <p id="Examples1_InText">
    One such project utilising a cluster of computers for calculations was the Millenium Simulation. In the ‘Methods’ section of “Simulations of the formation, evolution and clustering of galaxies and quasars”, the authors describe how they used 512 processors from an IBM p690 installation at the Computing Centre of the Max-Planck Society in Garching, Germany. They also mention that it took “350,000 processor hours of CPU time, or 28 days of wall-clock time” <a href="#ref4">(Springel, White, Jenkins, <i>et al</i> 2005)</a></p>
  <p id="Examples2_InText">
Another project that is utilising high performance computer clusters is the European Organisation for Nuclear Research (CERN). In a recently published article, written by Tommaso Boccali et al, they describe how CERN is experimenting with sending data to offsite locations to be computed during high load occasions, such as when the Large Hadron Collider (LHC) is actively being used. <a href="#ref2">(Boccali, <i>et al</i> 2021)</a> This highlights the problem with not having enough on-site computing power, and shows how even well-developed facilities such as the LHC and CERN require increased support when it comes to high powered computing clusters.

  </p>
</div>


<div class="reference">
  <h3 id="References">VI: References</h3>
  <p class="ex1">
    <pre> 
<a id="ref1" href="https://doi.org/10.1002%2F%28SICI%291097-024X%28199905%2929%3A6%3C551%3A%3AAID-SPE248%3E3.0.CO%3B2-C" style="text-decoration: none;">
Baker, M. Buyya, R. (1999) 'Cluster Computing: The Commodity Supercomputer', <i>SOFTWARE-PRACTICE AND EXPERIENCE</i>, 29(6), page 553
DOI:"https://doi.org/10.1002%2F%28SICI%291097-024X%28199905%2929%3A6%3C551%3A%3AAID-SPE248%3E3.0.CO%3B2-C"</a>


<a id="ref2" href="https://doi.org/10.1007/s41781-020-00052-w" style="text-decoration: none;">
Boccali, T. Cameron, D. <I>et al</I> (2021) 'Dynamic Distribution of High-Rate Data Processing from CERN to Remote HPC Data Centers', <I>Computing and Software for Big Science</I>, 5(7) page 1.
DOI:"https://doi.org/10.1007/s41781-020-00052-w"</a>
  
<p id="ref3">Buyya, R. (1999) 'High Performance Cluster Computing: Systems and Architectures, Volume 1', Prentice Hall, New Jersey USA.
</p>   
  
<a id="ref4" href="https://doi.org/10.1038/nature03597" style="text-decoration: none;">Springel, V. White, S. Jenkins, A. <I>et al</I> (2005) 'Simulations of the formation, evolution and clustering of galaxies and quasars.'. <I>Nature</I> 435, pages 629-636.
DOI:"https://doi.org/10.1038/nature03597"</a>
</pre>
</p>
</div>
<!-- //////////////////////////////////////////////////////////////////////////////// -->
  <!-- ////////////////////////////// Adding last update ////////////////////////////// -->
  <!-- //////////////////////////////////////////////////////////////////////////////// -->
    <!-- Last commit time display -->
<div id="last-updated">Loading last update time...</div>
<!-- Verify Button -->
<button onclick="verifyLastUpdatedTime()" style="display: block; margin: 10px auto; padding: 8px 16px;">
    Verify Last Modified Time
</button>
<script>
    async function getLastUpdatedTime() {
        const username = 'FEPSFY6931526';
        const repo = 'FY6931526';
       
        const url = `https://api.github.com/repos/${username}/${repo}/commits`;
        try {
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Accept': 'application/vnd.github.v3+json',
                }
            });
            if (!response.ok) {
                throw new Error(`Error fetching data: ${response.status} - ${response.statusText}`);
            }
            const commits = await response.json();
            if (commits && commits.length > 0) {
                const lastCommitDate = new Date(commits[0].commit.committer.date);
               
                // Displaying the time on load
                document.getElementById('last-updated').innerText = `Last Modified Time: ${lastCommitDate.toLocaleString()}`;
            } else {
                document.getElementById('last-updated').innerText = 'No commits found in the repository.';
            }
        } catch (error) {
            console.error('Error fetching the last updated time:', error);
            document.getElementById('last-updated').innerText = 'Error fetching update time. Please check the repository details.';
        }
    }
    // Function to verify the last update time by re-fetching it from the API
    async function verifyLastUpdatedTime() {
        document.getElementById('last-updated').innerText = 'Verifying...';
        await getLastUpdatedTime();
        alert("Last modified time has been successfully verified from GitHub API.");
    }
    // Initial load to display the time on page load
    window.onload = getLastUpdatedTime;
</script>


 <!-- //////////////////////////////////////////////////////////////////////////////// -->
  <!-- ////////////////////////////// Word count function ////////////////////////////// -->
  <!-- //////////////////////////////////////////////////////////////////////////////// -->
<!-- Placeholder for total word count -->
<p id="totalWordCount"></p>
<hr>
<script>
  // Function to calculate and display word count for a specified section
  function displayWordCount(sectionId, outputId) {
    // Get the text content from the specified section
    const text = document.getElementById(sectionId).textContent;
    // Split text into words based on spaces and filter out any empty strings
    const wordArray = text.trim().split(/\s+/);
    // Count the words
    const wordCount = wordArray.length;
    // Return the word count for summing purposes
    return wordCount;
  }
  // Function to calculate and display total word count from selected sections
  function displayTotalWordCount() {
    // Calculate word count for each section and accumulate the total

    // These next two lines can be chagned to match the ID of each paragraph that matters!
    // Don't forget to change them once the paragraphs are written
    
    const IntroductionCount = displayWordCount("Introduction_InText");
    const WhatCount = displayWordCount("What_InText");
    const HowCount = displayWordCount("How_InText");
    const WhyCount = displayWordCount("Why_InText");
    const Examples1Count = displayWordCount("Examples1_InText");
    const Examples2Count = displayWordCount("Examples2_InText")
    // Calculate the sum of all selected sections
    const totalWordCount = IntroductionCount + WhatCount + HowCount + WhyCount + Examples1Count + Examples2Count;
    // Display the total word count
    document.getElementById("totalWordCount").innerText = `Total word count: ${totalWordCount}`;
  }
  // Run the function for specific sections and display total count when the page loads
  window.onload = displayTotalWordCount;
</script>

  
  
</body>
</html>
