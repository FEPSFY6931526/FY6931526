<!DOCTYPE html>

<html>
  <head>
  <img src ="WebBanner2023.png" alt="Banner" width="900" height="300">
    <h1><b>ENG0018 Computer Laboratory 2025/26</b></h1>
    <h2>Student URN: 6931526</h2>
  <hr>
  <h2 style="font-family:calibri;"><b>Conference paper: An Analysis of the use of Cluster Computing for simulating complex models</b></h2>
  <hr>


  <!style for tables>
    <style>
        table {
            font-family: arial, sans-serif;
            border-collapse: collapse;
            width: 30%;
        }
        td, th {
          border: 1px solid #dddddd;
          text-align: left;
          padding: 8px;
        }

        tr:nth-child(even) {
          background-color: #dddddd;
        }
      
    </style>
    <style>
      p.ex1 {
        margin-left: 250px;
      }
    </style>
  </head>
<meta name="viewport" content="width=device-width, intial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<style>
  .mySlides {display:none}
</style>
<body style="background-color:#FFFFFF;margin-left:50px;">
  <hr>

<p class="ex1">
<!table of contents>
  <table>
    <tr>
      <th><h3>Table of contents</h3></th>
    </tr>
    <tr>
      <td><a href="#Abstract">Abstract</td>
    </tr>
    <tr>
      <td><a href="#Introduction">Section I: An Introduction</td>
    </tr>
    <tr>
      <td><a href="#Investigation">Section II: An investigation into the process of cluster computing</td>
    </tr>

    <tr>
      <td><a href="#References">References</td>
    </tr>
  </table>
</p>
  
  <hr>
  <h3 id="Abstract">Abstract</h3>
  <p class="ex1">
    <pre>
      THIS IS WHERE THE ABSTRACT WILL GO
    </pre>
  </p>
  <hr>
  <h2 id="Introduction">Introduction</h2>
  <p id="Introduction_InText"">
      There are many areas of science that benefit from viewing the interactions of their fields, and using software to do so can eliminate the potential risk involved with performing an actual experiment. This becomes an issue when you start to look at larger data sets, because a single computer can only perform x number of instructions per second, and this creates a time frame around an action. If each action has a time frame, then for every action you need to perform, you have a time in which the computer cannot do anything else. This time adds up, especially on larger data, or more complex calculations. The use of a group of computers arranged in a cluster instead allows multiple actions to be performed at a time by spreading the data and instructions between multiple processors and machines, decreasing the time it would take to perform all the instructions necessary to simulate a complex model.
  </p>

  <h3 id="Analysis and discussion">Section II: An investigation into the process of cluster computing</h3>
  <p id="Analysis_InText">
      Say there is a large data set regarding some important data that a group of scientists require for a simulation to determine whether a project or experiment should go ahead. If a single computer was designated to run a program that would run in a certain amount of time, or at least at a time proportional to the data set used in the simulation. We can give that time a value of x. Now the computer used to run the simulation has a processor with 8 processing cores and 8 virtual cores. These cores each can run one instruction at a time, meaning that at any given time, the computer can execute 16 instructions at once. If sixteen cores will require x time to run through the simulation, then how would 32 cores compare? What about 64?
      The whole process of cluster computing is to share the workload over multiple machines, with multiple cores, thus spreading out the process across more cores, and creating a parallel system. Looking back at my example above, if the simulation software was instead adapted to run on a cluster system, then that time frame x can be shortened.
  </p>
  <table>
    <tr>
      <th>Â£ Cost of repairs</th>
      <th>Lifespan of repairs (years)</th>
    </tr>
    <tr>
      <td>0.7 m</td>
      <td>2</td>
    </tr>
    <tr>
      <td>3.3 m</td>
      <td>4</td>
    </tr>
    <tr>
      <td>2.6</td>
      <td>5</td>
    </tr>
    <tr>
      <td>17.4 m</td>
      <td>7</td>
    </tr>
    <tr>
      <td>8.8 m</td>
      <td>9</td>
    </tr>
  </table>


  <h3 id="References">References</h3>
  <p>
    <pre>
      Sadashiv, N. and Kumar, S.M.D (2011) 'Cluster, grid and cloud computing: A detailed comparison',<i>
      2011 6th International Conference on Computer Science & Education (ICCSE)</i> UNFINISHED


      <u>Angluin, D (1988), Queries and concept learning. Machine learning 2, (4), 319-342.

      Brinker, K (2003), Incorporating Diversity in Active Learning with Support Vector Machines,
      Proceedings of the Twentieth International Conference on Machine Learning (ICML-2003).

      Bruzzone, L, Chi, M and Marconcini, M (2006), A novel transductive SVM for semisupervised classification of remote-sensing images,
      IEEE Transactions on Geoscience and Remote Sensing, 44, (11), 3363.

      Campbell, C, Cristiani, N and Smola, A (2000), Query learning with large margin classifiers.
      In: Proc. 17th Internat. Conf. on Machine Learning. Morgan Kaufman, Stanford, CA,111-118.
    </u>
    </pre>
  </p>

<!-- //////////////////////////////////////////////////////////////////////////////// -->
  <!-- ////////////////////////////// Adding last update ////////////////////////////// -->
  <!-- //////////////////////////////////////////////////////////////////////////////// -->
    <!-- Last commit time display -->
<div id="last-updated">Loading last update time...</div>
<!-- Verify Button -->
<button onclick="verifyLastUpdatedTime()" style="display: block; margin: 10px auto; padding: 8px 16px;">
    Verify Last Modified Time
</button>
<script>
    async function getLastUpdatedTime() {
        const username = 'FEPSFY6931526';
        const repo = 'FY6931526';
       
        const url = `https://api.github.com/repos/${username}/${repo}/commits`;
        try {
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Accept': 'application/vnd.github.v3+json',
                }
            });
            if (!response.ok) {
                throw new Error(`Error fetching data: ${response.status} - ${response.statusText}`);
            }
            const commits = await response.json();
            if (commits && commits.length > 0) {
                const lastCommitDate = new Date(commits[0].commit.committer.date);
               
                // Displaying the time on load
                document.getElementById('last-updated').innerText = `Last Modified Time: ${lastCommitDate.toLocaleString()}`;
            } else {
                document.getElementById('last-updated').innerText = 'No commits found in the repository.';
            }
        } catch (error) {
            console.error('Error fetching the last updated time:', error);
            document.getElementById('last-updated').innerText = 'Error fetching update time. Please check the repository details.';
        }
    }
    // Function to verify the last update time by re-fetching it from the API
    async function verifyLastUpdatedTime() {
        document.getElementById('last-updated').innerText = 'Verifying...';
        await getLastUpdatedTime();
        alert("Last modified time has been successfully verified from GitHub API.");
    }
    // Initial load to display the time on page load
    window.onload = getLastUpdatedTime;
</script>


 <!-- //////////////////////////////////////////////////////////////////////////////// -->
  <!-- ////////////////////////////// Word count function ////////////////////////////// -->
  <!-- //////////////////////////////////////////////////////////////////////////////// -->
<!-- Placeholder for total word count -->
<p id="totalWordCount"></p>
<hr>
<script>
  // Function to calculate and display word count for a specified section
  function displayWordCount(sectionId, outputId) {
    // Get the text content from the specified section
    const text = document.getElementById(sectionId).textContent;
    // Split text into words based on spaces and filter out any empty strings
    const wordArray = text.trim().split(/\s+/);
    // Count the words
    const wordCount = wordArray.length;
    // Return the word count for summing purposes
    return wordCount;
  }
  // Function to calculate and display total word count from selected sections
  function displayTotalWordCount() {
    // Calculate word count for each section and accumulate the total

    // These next two lines can be chagned to match the ID of each paragraph that matters!
    // Don't forget to change them once the paragraphs are written
    
    const IntroductionCount = displayWordCount("Introduction_InText");
    const AnalysisCount = displayWordCount("Analysis_InText");
    // Calculate the sum of all selected sections
    const totalWordCount = IntroductionCount + AnalysisCount;
    // Display the total word count
    document.getElementById("totalWordCount").innerText = `Total word count: ${totalWordCount}`;
  }
  // Run the function for specific sections and display total count when the page loads
  window.onload = displayTotalWordCount;
</script>

  
  
</body>
</html>
